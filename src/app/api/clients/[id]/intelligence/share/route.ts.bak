import { isDbAvailable, requireDbAsync } from '@/lib/db-guard';
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma-compat";
import { randomUUID } from "crypto";
import {
  ActivityType,
  ActivityCategory,
  ActivityStatus,
  Priority,
} from "@/types/client";
// Note: Simplified to work with current Drizzle schema

export async function POST(
  req: NextRequest,
  { params }: { params: { id: string } },
) {
  if (!isDbAvailable()) {
    return NextResponse.json(
      { error: 'Service temporarily unavailable' },
      { status: 503 }
    );
  }
  
  try {
    // Authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id: clientId } = params;
    const body = await req.json();
    const {
      expiresIn = "7d",
      includeFinancials = false,
      password = null,
      recipientEmail = null,
      sections = ["overview", "readiness", "recommendations"],
    } = body;

    // Verify client access
    const client = await prisma.client.findFirst({
      where: {
        id: clientId,
        organizationId: session.user.organizationId,
        ...(session.user.role === "ADVISOR"
          ? {
              advisorId: session.user.id,
            }
          : {}),
      },
    });
    if (!client) {
      return NextResponse.json({ error: "Client not found" }, { status: 404 });
    }
    // Calculate expiration date
    const expiresAt = new Date();
    switch (expiresIn) {
      case "1d":
        expiresAt.setDate(expiresAt.getDate() + 1);
        break;
      case "3d":
        expiresAt.setDate(expiresAt.getDate() + 3);
        break;
      case "7d":
        expiresAt.setDate(expiresAt.getDate() + 7);
        break;
      case "30d":
        expiresAt.setDate(expiresAt.getDate() + 30);
        break;
      default:
        expiresAt.setDate(expiresAt.getDate() + 7);
    }
    // Generate secure token
    const token = randomUUID().replace(/-/g, "");
    // Create share record (you'd need to add this to your schema)
    const shareLink = {
      id: randomUUID(),
      clientId,
      userId: session.user.id,
      token,
      expiresAt,
      includeFinancials,
      password,
      recipientEmail,
      sections,
      accessCount: 0,
      maxAccess: 10, // Default max access
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    // In a real implementation, you'd store this in your database
    // For now, we'll return the share URL
    const shareUrl = `${process.env.NEXT_PUBLIC_APP_URL}/shared/intelligence/${token}`;
    // Log the share creation
    await prisma.clientActivity.create({
      data: {
        clientId,
        userId: session.user.id,
        type: ActivityType.NOTE,
        category: ActivityCategory.REVIEW,
        title: "Intelligence Report Shared",
        description: `Shared intelligence report with ${recipientEmail || "anonymous recipient"} - expires ${expiresAt.toLocaleDateString()}`,
        status: ActivityStatus.COMPLETED,
        taskPriority: Priority.MEDIUM,
        completedAt: new Date(),
      },
    });
    return NextResponse.json({
      shareUrl,
      token,
      expiresAt,
      includeFinancials,
      sections,
      message: "Share link created successfully",
    });
  } catch (error) {
    console.error("Error creating share link:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 },
    );
  }
}

// Get share link details
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } },
) {
  if (!isDbAvailable()) {
    return NextResponse.json(
      { error: 'Service temporarily unavailable' },
      { status: 503 }
    );
  }
  
  try {
    // Authentication
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id: clientId } = params;

    // In a real implementation, you'd fetch active share links from database
    // For now, return placeholder data
    const shareLinks = [
      {
        id: randomUUID(),
        token: randomUUID().replace(/-/g, ""),
        createdAt: new Date(),
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        accessCount: 0,
        maxAccess: 10,
        recipientEmail: "client@example.com",
        isActive: true,
      },
    ];

    return NextResponse.json({
      shareLinks,
      message: "Share links retrieved successfully",
    });
  } catch (error) {
    console.error("Error fetching share links:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 },
    );
  }
}
